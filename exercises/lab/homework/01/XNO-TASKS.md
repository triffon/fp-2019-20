# "Изкуствен интелект" за морски шах

## Описание на файловата структура

В папката с домашните (`hw`) има директория `hw03` със следната структура:
```
hw03
├── gui
│   ├── utils.rkt
│   └── xno.rkt
├── impl.rkt
└── main.rkt
```

Подпапката `gui` съдържа много просто имплементиран графичен интърфейс към играта на морски шах. В общия случай въобще не е нужно да гледате, вътре, че и препоръчвам да не гледате, защото е доста грозно (do as I say, not as I do). Накратко `xno.rkt` има самия интърфейс, а `utils.rkt` има някакви помощни функции, които си направих.

Файлът `main.rkt` е много прост – служи за нещо, което да пуснете през `racket` или `DrRacket`. При изпълняване на `(main)` се пуска графичният интърфейс от `gui/xno.rkt`, като се използват функциите, които седят във файла `impl.rkt` за съответно определяне на победител и ход на компютъра. С него можете да цъкате и да си тествате "изкуствения интелект"

Файлът `impl.rkt` е вашата задача – в него има две функции – `(winner b)` и `(play curr-board curr-sign)`, които вие трябва да имплементирате. Те се `require`-ват и се викат от `xno.rkt`.

За момента те имат две "тъпи" имплементаций – `(winner b)` засича само игри, приключили в равенство, а пък `(play curr-board curr-sign)` винаги играе първото свободно място, от ляво надясно, от горе надолу. Вие трябва да направите `(winner b)` да засича всички възможни изходи (уточнено по-долу) и `(play curr-board curr-sign)` да е "изкуствен интелект", който да не може да загуби.

Освен съществуващите в момента файлове, вероятно ще искате в папката `hw03` да сложите и вашата библиотека за матрици от [02-hw.md], за да можете да я ползвате сега.

### Определение на `Дъска`
**Дъска** ще наричаме **матрица** която изпълнява следните допълнителни условия:

01. Матрицата винаги е с размер три на три (винаги има три списъка в нея, всеки от които има три елемента).

02. Елементите на матрицата винаги са едно от следните три - `"X"` `"O"` и `#f`. Семантиката на `#f` е "празно място".

Примери за дъска:
```scheme
; изцяло празна дъска
'((#f #f #f)
  (#f #f #f)
  (#f #f #f))

; запълнена дъска
'(("X" "O" "X")
  ("O" "X" "O")
  ("X" "O" "X"))

; дъска, на която има някакво личице
'(("O" #f "O")
  (#f "O" #f)
  ("X" "X" "X"))
```

### Определение на `Победител`
**Победител** може да има една от следните четири стойности:

01. `"X"` – играчът който играе с "X" е спечелил.

02. `"O"` – играчът който играе с "O" е спечелил.

03. `"D"` – играта е завършила наравно.

04. `#f` – играта не е завършила.

## TODO(georgi): Move everything above here to top level task Описание на функциите, които трябва да реализирате
## TODO(georgi): Describe high-level overview of task (winner, play, suggested minmax)
Моят замисъл за имплементацията на тази функция е да се използва `minmax` алгоритъма. В описанието на задачата ще опиша какво представлява той неформално
и какви стъпки/под-функции бих/съм написал аз за да го реализирам. Нямам нищо против вие да измислите друго решение, стига то да изпълнява
следните две условия:

1. Да се справя поне толкова добре колкото `minmax` решението (т.е. никога да не губи).
2. Да може решенето лесно да се адаптира за дъска с размерност `NxN` дъска, за произволно естествено `N`.

    (Това очевидно изключва решения които са много на брой вложени if-ове)

## 00. `(winner b)`
`(winner b)` взима дъска `b` и връща кой е победител на тази дъска.

Примери:

```scheme
(winner '((#f #f #f)
          (#f #f #f)
          (#f #f #f))) ;-- #f

(winner '(("X" "O" "X")
          ("O" "X" "O")
          ("X" "O" "X"))) ;-- "X"

(winner '(("O" "O" "O")
          ("X" "X" #f)
          (#f #f "X"))) ;-- "O"

(winner '(("O" #f "O")
          (#f "O" #f)
          ("X" "X" "X"))) ;-- "X"

(winner '(("X" "O" "O")
          ("O" "X" "O")
          ("O" "X" "X"))) ;-- "X"

(winner '(("X" "O" "X")
          ("O" "X" "O")
          ("O" "X" "O"))) ;-- "D"

(winner '(("X" "O" "X")
          ("O" "O" "X")
          ("O" "X" #f))) ;-- #f
```

## 01. `(play curr-board curr-sign)`
`play` взима дъска `curr-board` и знак `curr-sign`- знакът който е на ход сега.
Функцията връща къде да бъде игран ход, като наредена двойка от два индекса в дъската ни

Ето **[тук][minmax]** има описание на алгоритъма.

Идеята е следната – ще се опитваме да оценим всички дъски (тоест състояние) на морски шах с някакво число. Тъй като в тази игра има само три изхода
(и ние няма да се интересуваме от някакви евристики) ще дадем три оценки – `-1` `0` `1`.

Стойност `1` ще даваме на дъски, които са печеливши за нас, тоест знаем че от тях ние със сигурност имаме победа.

Стойност `0` ще даваме на дъски, на които най-добрата ни игра ще доведе до равенство.

А пък стойност `-1` ще даваме на дъски, на които най-добрата ни игра ще доведе до загуба.

А как да преценим произволна дъска до какъв извод ще ни доведе? Ами това е работата на алгоритъма.

Да започнем от най-простия случай – завършена дъска. Ако имаме една запълнена дъска и знаем ние с кой знак играем (`"X"` или `"O"`),
то знаем и каква оценка да ѝ дадем – с малко донагаждане на функцията `winner`.

За (мое) улеснение празните места ще индикирам с `_`.

Пример:

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**_**|**_**|**X**|

Ако тук играем с `X` ще дадем на тази дъска оценка `1`, защото сме спечелили.

Сега да си помислим за предпоследния ход преди да се стигне до завършена дъска. Да предположим че от горната дъска
последно сме сложили `X` в долния десен ъгъл, (тоест на координати `2` `2`). Да видим как би изглеждала дъската преди това:

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**_**|**_**|**_**|

Тази дъска е очевидна за нас – слагайки долу в дясно `X`, печелим. Но за момента нямаме начин да дадем таква оценка алгоритмично.

Тогава какво можем да направим? Как реално преценяваме, като хора, че можем да спечелим слагайки там `X`?

Има три възможни позиции на които може да поставим `X`:

01.

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**X**|**_**|**_**|

02.

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**_**|**X**|**_**|

03.

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**_**|**_**|**X**|

Ако можем да оценим всяка от тях и да изберем, тази с най-голяма оценка (да **максимизираме** печалбата ни),
то очевидно ще играем там. E третата дъска вече я оценихме с `1`, което в този случай е най-високата оценка, но да предположим за примера,
че трябва първо да оценим и другите две преди да можем да изберем най-голямата (пример за това би било ако имаше някакво точкуване в морския шах).

Да хванем да оценим дъска **01.**. Но тя не е финална дъска – как ще я оценим? Ами точно както ние видяхме възможните полета за игра и казахме че ще ги оцнеим
и след това ще изберем най-добрата от тях за нас, то и противникът ни може същото. Затова ние ще изсимулираме неговите възможности и неговия избор
по същия начин. Ще сложим на всяка свободна позиция `O`, и ще видим коя е най-печеливша за противника ни. Само че ние даваме оценки от наша гледна точка,
тоест най-печелившата за противника е най-лошата за нас (`-1`). Поради тази причина ние трябва сега да дадем оценка на следващите възможни дъски
и този път да изберем тази дъска с **най-малка** оценка (да **минимизираме** печалбата ни), знаейки че противникът ще иска да играе там.

Възмоностите са:

01.

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**X**|**O**|**_**|

02.

|**X**|**O**|**O**|
|-----|-----|-----|
|**O**|**X**|**X**|
|**X**|**_**|**O**|

Е тук пак сме ние на ход – може да приложим същата тактика, но този път избирайки най-голямата от следващите дъски. Тук очевидно и в двата случая
стигаме до равенство. И двете дъски се оценяват до `0` – и противникът ни ще избере по-добрата за него – тази с по-малка стойност, което в този случай
е `0`, защото и двете дъски са с оценка `0`. Сега вече знаем, че ако играем в долния ляв ъгъл то дъската непременно ще стигне до оценка `0`,
тъй като противникът ни играе след това и избира най-лошото за нас и освен това той току-що е оценил че най-лошото за нас (от тази позиция) е `0`.

Сега ни остана само да оценим първоначалните дъски 02. и 03. Да предположим че вече сме приложили тази схема  за тях и сме стигнали съответно до оценки `0` и `1`.
То за да оценим сегашната ни дъска (първоначалната, на която се чудехме какво да сложим), ни остава само да изберем коя е най-голямата от тези оценки, защото все пак
ние сме на ход и можем да изберем най-доброто за нас.

В есенцията си това е един рекурсивен процес, чието дъно се определя от състоянието на дъската (`winner` функцията), и който на всяко рекурсивно извикване
прави обратния избор на предишното (**min**imum vs **max**imum).

Тъй като не знам това обяснение колко помогна ще изложа моя мисловен процес докато го пишех това нещо:

### Disclaimer: Тъй като може би съм дал _твърде_ подробно опътване _силно_ препоръчвам да пробвате първо сами да реализирате алгоритъма без въобще да гледате по-надолу.


01. `(empty-spots xss)`

    Взима дъска `xss` и връща списък от наредени двойки индексите на незапълнените позиции. Това ще е функцията, която ни дава възможните позиций, от сегашната.

    Примери:

    ```scheme
    (empty-spots '(("X" "O" "X")
                   ("X" "O" "O")
                   ("O" "X" "X"))) ;-- '()

    (empty-spots '((#f  "O" "X")
                   ("X" "O" "O")
                   ("O" "X" "X"))) ;-- '((0 . 0))

    (empty-spots '((#f  "O" "X")
                   ("X" "O" "O")
                   ("O" #f  "X"))) ;-- '((0 . 0) (2 . 1))
    ```

    За реализацията на тази функция може да ви е полезно да имате "индексна матрица" –
    на `i` `j`-тия индекс на матрицата, седи наредената двойка `(i . j)`.

02. `(grade win me)`

    Взима победител `win` и кой играч съм аз `me` (#t за "X", #f за "O") и връща колко точки трябва да се дадат за този победител.

    Примери:

    ```scheme
    (grade "D" #t) ;-- 0

    (grade "D" #f) ;-- 0

    (grade "X" #f) ;-- -1

    (grade "X" #t) ;-- 1

    (grade "O" #f) ;-- 1

    (grade "O" #t) ;-- -1
    ```

03. `(maximum-on f xs)`

    Взима функция `f`, която да приложи върху елементите на списъка `xs`, преди да избере този от тях, с най-голяма стойност след приложението на функцията.

    Примери:

    ```scheme
    (maximum-on id '(1 2 3)) ;-- 3

    (maximum-on (lambda (x) (-x)) '(1 2 3)) ;-- 1

    (maximum-on car '((1 . 1337) (0 . 20000) (10 . 4))) ;-- (10 . 4)

    (maximum-on cdr '((1 . 1337) (0 . 20000) (10 . 4))) ;-- (0 . 20000)
    ```

04. `(maximise board curr-player me)` и `(minimise board curr-player me)`

    Функциите, които реално реализират оценявато на една дъска `board`, като взимат
    кой играе сега на ход `curr-player` и от коя гледна точка `me` (`#t` или `#f` отново) се оценява дъската.

    Те са реално дуални, като единствено се различават по какво сравнение правят
    (`max` vs `min`).

    Идеята в тях е да видим дали сме ударили дъно, след което ако не сме
    да продължим рекурсията си надолу, извиквайки дуалната на сегашната (за да отразим факта, че на следващия ход играе другият играч).

    След като ги напишете много бързо ще видите че може и да е една функция, с малко абстрахиране.



[minmax]: https://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves
