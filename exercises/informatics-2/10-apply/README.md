Функции с произволен брой аргументи
-----------------------------------

1. Да се дефинира функцията `(maximum n1 n2 ... nK)`,
която намира максималното число сред дадени `n1`, `n2`, ..., `nK`,
които могат да бъдат произволен брой.

1. Да се дефинира функцията `(concat l1 l2 ... lN)`,
която конкатенира произволен брой дадени списъци в един списък.

    Използвайте `.` в аргументите на функцията. `apply` върви ръка за ръка с `.`.

    Пример: `(concat '(1) '(13 12) '() '(42 17 9))` връща `'(1 13 12 42 17 9)`.

1. Да се дефинира функцията `(zip-with f l1 l2)`,
която връща нов списък, в който всеки елемент на позиция N
е резултатът от прилагането на бинарната функцията `f`
върху елементите на същата позиция N в списъците `l1` и `l2`.
Ако списъците не са с еднаква дължина, резултатния списък е с по-малката дължина от двете.

   `zip-with` e като `zip`, но вместо да връща наредените двойки, директно ги комбинира.

    Например, `(zip-with + '(1 3 5 7 9) '(2 4 6 8 9))` връща `'(3 7 11 15 18)`.

    Буквално си представете, че движим надолу `+` като цип между двата списъка:

    ```scheme
    1 + 2  =>    3          3          3          3          3
    3 + 4      3 + 4  =>    7          7          7          7
    5 + 6      5 + 6      5 + 6  =>    11         11         11
    7 + 8      7 + 8      7 + 8      7 + 8  =>    15         15
    9 + 9      9 + 9      9 + 9      9 + 9      9 + 9   =>   18
    ```

1. Да се дефинира `zip-with` над произволен брой списъци,
тоест `(zip-with f l1 l2 l3 ... lN)`, където `f` е `N`-местна функция.
Дължината на резултатния списък е дължината на най-късия от подадените списъци.

    Например, `(zip-with + '(1 2) '(3 4) '(5 6 7))` връща `'(9 12)`.

    ```scheme
    1 + 3 + 5  =>      9           9
    2 + 4 + 6      2 + 4 + 6  =>  12
            7 ; елементите в излишък се игнорират
    ```

1. Вече сме запознати с функцията `(map f l)`,
която връща нов списък с функцията `f` приложена върху всеки елемент на списъка `l`.
Знаете ли, че в Scheme `map` може да работи на произволен брой списъци?
Пробвайте я в интерпретатора например с `(map cons '(3 2 1) '(7 8 9))`.
Дефинирайте я сами! Oh wait... :thinking:

1. Дефинирайте функцията `(transpose m)`, която транспонира матрицата `m`,
но имате право само на една единствена комбинация (прилагане на функция).
Hint: Можем ли да използваме някоя от предходните функции? Ако да, как бихме я ... приложили в транспонирането на матрици. :thinking:

    Пример: `(transpose '((1 2) (3 4) (5 6)))` се оценява до `'((1 3 5) (2 4 6))`

1. Дефинирайте функцията `(partial f a1 a2 ... aK)`,
която прилага частично функцията `f` над произволен брой аргументи `a1`, `a2`, ..., `aK`,
където `f` е N-местна и `K <= N`.

    Пример:

    ```scheme
    (define double (partial * 2))
    (double 21) ; 42
    ```

1. Дефинирайте функцията `(pipe f1 f2 ... fN)`,
която по дадени произволен брой функции `f1`, `f2`, ..., `fN`
ги композира от ляво-надясно в нова функция,
която приема аргументите на `f1`, върху които се прилага `f2`,
върху която се прилага `f3` и т.н. до `fN`.

    Пример:

    ```scheme
    (define transform
      (pipe (partial map square)
            (partial filter even?)
            (partial foldl + 0)))

    (transform '(1 2 3 4 5 6)) ; 56
    ```
