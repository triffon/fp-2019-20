Упражнение 5
============

Примерни задачи за първо контролно
----------------------------------
1. Да се напише процедура `(middle-digit n)`, която намира средната цифра от
записа на подадено естествено число `n`. Ако `n` е с четен брой цифри,
процедурата да връща `-1`. Примери:

   ```scheme
   (middle-digit 452) ; -> 5
   (middle-digit 4712) ; -> -1
   ```

2. Нека е даден списък `l` от числа и двуместна операция над числа ⊕. Функцията
`f` наричаме ендоморфизъм над `l` спрямо операцията ⊕, ако `f` трансформира `l`
в себе си, запазвайки операцията ⊕, тоест

   ∀x∈l f(x)∈l и\
   ∀x,y∈l f(x) ⊕ f(y) = f(x ⊕ y).

   Да се реализира процедура `(endomorphism? l op f)`, която проверява дали `f`
   е ендоморфизъм над `l` спрямо операцията `op`. Примери:
   ```scheme
   (endomorphism? '(0 1 4 6) + (lambda (x) (remainder x 3))) ; -> #t
   (endomorphism? '(0 1 4 5 6) + (lambda (x) (remainder x 3))) ; -> #f
   ```

3. Да се напише процедура `(meet-twice? f g a b)`, която проверява дали в
целочисления интервал [`a`, `b`] съществуват две различни цели числа `x` и `y`
такива, че f(x) = g(x) и f(y) = g(y). Примери:

   ```scheme
   (meet-twice? (lambda (x) x) (lambda (x) (- x)) -3 1) ; -> #f
   (meet-twice? (lambda (x) x) sqrt 0 5) ; -> #t
   ```

4. Казваме, че списъкът `x` = (x<sub>1</sub> x<sub>2</sub> … x<sub>2n</sub>) от
цели числа се получава от прочитането (look-and-say) на списъка `y`, ако `y` се
състои от последователно срещане на x<sub>1</sub> пъти x<sub>2</sub>, последвано
от x<sub>3</sub> пъти x<sub>4</sub> и така нататък до x<sub>2n-1</sub> пъти
x<sub>2n</sub>. Да се дефинира процедура `(next-look-and-say y)`, която по даден
списък `y` намира списъка `x`, получен от прочитането на `y`. Примери:

   ```scheme
   (next-look-and-say '(1 1 2 3 3)) ; -> (2 1 1 2 2 3)
   (next-look-and-say '(1 1 2 2 3 3 3 3)) ; -> (2 1 2 2 4 3)
   ```

Още задачи
----------
Да се напише:
1. процедура [`(selection-sort l)`](selection-sort.scm), която сортира списъка
`l` по метода на пряката селекция.

2. процедура [`(quicksort l)`](quicksort.scm), която сортира списъка `l` чрез
алгоритъма "бързо сортиране" (quicksort).

3. процедура [`(prime-sum-pairs n)`](prime-sum-pairs.scm), която по дадено цяло
положително число `n` намира всички наредени тройки (i, j, i + j), за които:

   i и j са цели положителни числа,\
   1 ≤ j < i ≤ n и\
   i + j е просто.
